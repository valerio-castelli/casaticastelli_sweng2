\chapter{Functional role}
This chapter provides an overview of the functional role of the \textbf{ActiveJmsResourceAdapter} class, and specifically of its \textbf{createManagedConnectionFactory} and \textbf{createManagedConnectionFactories} methods, in the general context of the whole Glassfish Project.

In order to make the analysis more clear and understandable, we provide a brief list of acronyms and definitions which are used throughout the code:
\begin{itemize}
	\item \textbf{EIS: Enterprise Information System}. It's a generic term that refers to any kind of information system (or component thereof) used in an enterprise context, including ERP (Enterprise Resource Planning) systems, message brokers and others.
	\item \textbf{RA: Resource Adapter}. It's a component that implements the adapter design pattern to let two systems communicate with each other when there is a discrepancy between the offered and required interfaces. In the specific case of Glassfish, resource adapters are used to interface with external EISs.
	\item \textbf{MQ: Message Queue}. Despite the name, this component usually doesn't simply implement a location where messages are stored until delivery, but takes care of the whole stack of messaging functionalities to enable communications between interconnected components. 
	\item \textbf{MB: Message Broker}. It's a component that enriches the functionalities of a message queue by also providing appropriate mechanisms to translate messages between different formats. This is essential to adapt them to the different kinds of senders and receivers that exchange messages across the network. 
	\item \textbf{imq properties}: set of configuration properties of the IBM WebSphere MQ software suite. Glassfish implements mechanisms to handle them as part of the resource adapter that provides the interface with IBM MQ compliant message brokers. They are supported mainly for compatibility reasons, since they've been superseded by later revisions of the MQ API. 
	\item \textbf{AS7 properties}: set of properties of Application Servers, implemented both by JBoss and Glassfish. They include the already mentioned imq properties. 
	\item \textbf{XA standard}: specification written by The Open Group for distributed transaction processing (DTP). It describes the interface between the global transaction manager and the local resource manager. The goal of XA is to allow multiple resources (such as databases, application servers, message queues, transactional caches, etc.) to be accessed within the same transaction, thereby preserving the ACID properties across applications. XA uses a two-phase commit to ensure that all resources either commit or rollback any particular transaction consistently (all do the same). In the case we are considering, the role of global transaction manager is implemented by a Glassfish instance, while the local resource managers are the different message queues (or message brokers) to which the application server is connected. \footnote{\url{https://en.wikipedia.org/wiki/X/Open_XA}}
	\item \textbf{RM: Resource Manager}. It is the component responsible for managing a set of resources. In the case we are considering, each message queue (or message broker) is a different resource manager. 
	\item \textbf{MCF: Managed Connection Factory}. It is the common interface implemented by all the adapter classes which provide connections toward an external service. As specified by the official Oracle Java EE Documentation\footnote{\url{https://docs.oracle.com/javaee/5/tutorial/doc/bnceh.html}}, a connection factory provides the necessary methods to create a connection to a provider and encapsulates all the required connection configuration parameters. In the case we are considering, the MCF is used to create and handle connections to message brokers implementing the JMS API.
\end{itemize}

Given these premises, it's then easy to understand that the primary purpose of \code{ActiveJmsResourceAdapter} is to provide a communication interface between Glassfish and any kind of external message broker supporting the JMS API.  

As defined by Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Java_Message_Service}},
\begin{quote}the \textbf{Java Message Service (JMS) API} is a Java Message Oriented Middleware (MOM) API for sending messages between two or more clients. It is a messaging standard that allows application components based on the Java Enterprise Edition (Java EE) to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous.
\end{quote}

The full JMS specification is available at Oracle's Developer Website\footnote{\url{http://www.oracle.com/technetwork/java/jms/index.html}}; we include the key architectural diagram here: 
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=250pt,keepaspectratio]{images/jms-programmingModel.png}}
\end{figure}

The \code{ActiveJmsResourceAdapter} component is essential for Glassfish to provide its hosted applications the messaging functionalities of the JMS API without having to implement a full message broker directly; instead, the system administrator is able to freely choose one (or more) of the existing commercial message brokers and configure Glassfish to route all JMS calls to it. In practice, it gives hosted applications a virtual, monolithic JMS message broker that they can interact with, fully abstracting all the implementation details of the specific adopted software solution.

In particular, it has the ability to connect with multiple message brokers at the same time to evenly distribute the amount of messages to be routed for performance and scalability reasons. Since each message broker has its own specific set of APIs, the actual implementation of the communication adapter is not directly provided by \code{ActiveJmsResourceAdapter}, which only acts as a general interface, but is offered by a set of different classes (one for each message broker) implementing the \code{ManagedConnectionFactory} interface which are dynamically loaded at runtime when needed.\\

Each distinct message broker is identified in Glassfish with a connector, which in turn can be associated with multiple connections at the same time. All the implementation details required to correctly interact with the message broker, including the name of the adapter class to be loaded, the values of the configuration properties and parameters and the maximum number of supported connections are specified by a \code{ConnectorConnectionPool} object. Despite the name, this object doesn't implement itself a connection pool, as it doesn't keep track of the connections that have been opened toward a certain message broker, instead being specifically concerned with the configuration details of the interface. The information provided by the \code{ConnectorConnectionPool} object is then used to dynamically load and instantiate the required \code{ManagedConnectionFactory} class.\\

The \code{createManagedConnectionFactory} method is precisely involved with the setup of the \code{ManagedConnectionFactory} object responsible for the communication with a specified JMS compliant message broker. The first instruction is a call to the implementation of this method defined by the \code{ActiveResourceAdapter} superclass, which performs three tasks:
\begin{itemize}
	\item It dynamically loads the class implementing the desired \code{ManagedConnectionFactory} implementation and instantiates it;
	\item For every property enumerated in the given \code{ConnectorConnectionPool}, it uses Java reflection to find out which is the corresponding setter method implemented by the \code{ManagedConnectionFactory} class and invokes it. This is essentially done because different \code{ManagedConnectionFactory} implementations support different sets of properties, which thus cannot be exposed at the interface level and therefore need to be discovered using Java reflection on the actual allocated class. 
	\item If everything has been successful, it returns a reference to the created \code{ManagedConnectionFactory} instance; otherwise, it returns null.
\end{itemize}

However, this code is only able to configure properties for which there exists a setter named using the \code{<attribute, setAttribute(value)>} pattern. Apparently, older implementations of the MQ API only provided properties in the form of \code{<property, value>} tuples which had to be passed to a \code{setProperty(String property, String value)} method; this properties starting with the “imq” prefix are thus not set by the initial call of the super \code{createManagedConnectionFactory} method.

For this reason, if a valid \code{ManagedConnectionFactory} instance is returned, the method proceeds to check all the properties stated in the \code{ConnectorConnectionPool} object looking for those who have “imq” as a prefix and, if any of them is found, it uses Java reflection to obtain the \code{setProperty(String property, String value)} method of the \code{ManagedConnectionFactory} instance and invokes it with the corresponding \code{<property, value>} tuple. If no such method is found, an exception is raised to notify the user that the configuration file is probably wrong (as it's trying to set a property that is not supported by the specific \code{ManagedConnectionFactory} instance). 

For compatibility reasons, the transition from imq properties using the \code{setProperty(String property, String value)} method to properties set with the \code{<attribute, setAttribute(value)>} pattern has led to the necessity of supporting both the old and the new naming schemes. This means that most properties still have an old, deprecated imq version and a newer non-imq version which should be used in lieu of the old one. If the two are present with different values in the same file, the newer non-imq one should be considered as the legal one.

However, since the imq loop is executed after all “newer” properties have already been set, if a lazy developer has actually included both the imq version and the newer non-imq version of the same property in the same file, the value of the imq version will overwrite the non-imq one as its corresponding setter is called later.

Since this is in contrast with the specification, Glassfish includes a fix for this behavior which consists of simply re-invoking all the setter methods for the non-imq properties, with the single exception of the \code{addressList} property which is removed in case the address is equal to localhost or is empty (as it is considered to be “less important” than a non-empty and non-localhost imq \code{addressList}). This check is only performed if the interfacing module is a JMS module, which in fact is a superfluous check as \code{ActiveJmsResourceAdapter} only deals with JMS modules. \\

As we were mentioning earlier, \code{ActiveJmsResourceAdapter} is able to associate multiple message brokers to the same virtual connector in order to achieve better scalability and performances. The interactions between all the resource managers (in this case, message brokers) are governed by the XA standard, which uses two-phase commit to ensure that transactions related to the processing of messages are correctly handled by all nodes.

The \code{createManagedConnectionFactories} method is invoked when it's necessary to gather all the instances of \code{ManagedConnectionFactory} associated with a pool of message broker addresses.

As the author of the code states in the comment at the beginning of the method, this is particularly useful when it is necessary to send a message to all the message brokers in a broker cluster. To achieve this, it is necessary to simultaneously get a reference to all the message brokers in the cluster in order to eventually instantiate a connection with each of them.

The process is actually quite straightforward. At first, the method determines how many message brokers are part of the cluster by counting the number of remote addresses in the pool. If only one message broker is present, a single \code{ManagedConnectionFactory} is created; otherwise, a list of all addresses is obtained by analyzing both the imqAddressList and the AddressList properties specified by the \code{ConnectorConnectionPool} configuration. It should be noted that, if both properties are defined, the actual set of addresses that will be considered will depend on the order in which the two properties are stated. Furthermore, if no address is specified in the \code{ConnectorConnectionPool} or if the only address found is localhost, the address configuration is overridden by the set of addresses defined by the \code{addressList} attribute of \code{ActiveJmsResourceAdapter}. This behavior doesn't seem to be consistent and is not clearly documented, as we will discuss later. 

For each address that has been obtained, a \code{ManagedConnectionFactory} is created. The process is similar to what we've already seen for the single \code{ManagedConnectionFactory}: the super method is invoked for the initial allocation and configuration phase, then all imq properties are set. The conflict resolution policy for imq and non-imq properties adopted in this case is different from what we've seen in the single factory case: this time, only the \code{addressList} property is resolved giving more importance to its non-imq version, while for all other properties the imq version overrides the non-imq one if both are present. It should be noted that the reasons for this discrepancy in the conflict resolution policy between \code{createManagedConnectionFactory} and \code{createManagedConnectionFactories} method is not documented, so there is no way to understand if this was made on purpose or if it's a bug in the code.