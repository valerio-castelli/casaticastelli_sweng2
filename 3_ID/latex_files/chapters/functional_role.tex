\chapter{Functional Role}
This chapter provides an overview of the functional role of the \textbf{ActiveJmsResourceAdapter} class, and specifically of its \textbf{createManagedConnectionFactory} and \textbf{createManagedConnectionFactories} methods, in the general context of the whole Glassfish Project.

In order to make the analysis more clear and understandable, we provide a brief list of acronyms and definitions which are used throughout the code:
\begin{itemize}
	\item \textbf{EIS: Enterprise Information System}. It's a generic term that refers to any kind of information system (or component thereof) used in an enterprise context, including ERP (Enterprise Resource Planning) systems, message brokers and others.
	\item \textbf{RA: Resource Adapter}. It's a component that implements the adapter design pattern to let two systems communicate with each other when there is a discrepancy between the offered and required interfaces. In the specific case of Glassfish, resource adapters are used to interface with external EISs.
	\item \textbf{MQ: Message Queue}. Despite the name, this component usually doesn't simply implement a location where messages are stored until delivery, but takes care of the whole stack of messaging functionalities across a network of interplaying components. 
	\item \textbf{imq properties}: set of configuration properties of the IBM WebSphere MQ suite, implemented by Glassfish as part of the resource adapter interface with IBM MQ compliant Message Brokers. Supported mainly for compatibility reasons since they've been superseded by later revisions of the MQ API. 
	\item \textbf{AS7 properties}: set of properties of Application Servers, implemented both by JBoss and Glassfish. They include the already mentioned imq properties. 
	\item \textbf{XA standard}: specification written by The Open Group for distributed transaction processing (DTP). It describes the interface between the global transaction manager and the local resource manager. The goal of XA is to allow multiple resources (such as databases, application servers, message queues, transactional caches, etc.) to be accessed within the same transaction, thereby preserving the ACID properties across applications. XA uses a two-phase commit to ensure that all resources either commit or rollback any particular transaction consistently (all do the same).\footnote{\url{https://en.wikipedia.org/wiki/X/Open_XA}}
	\item \textbf{RM: Resource Manager}. It is the component responsible for managing a set of resources; in the particular case of Message Queues, it coincides with the message broker. 
	\item \textbf{MCF: Managed Connection Factory}. It is the common interface implemented by all the adapter classes which provide connections toward an external service. As specified by the official Oracle Java EE Documentation\footnote{\url{https://docs.oracle.com/javaee/5/tutorial/doc/bnceh.html}}, a connection factory encapsulates a set of connection configuration parameters that has been defined by an administrator and provides to clients the necessary methods to create a connection to a provider.
\end{itemize}

The primary purpose of \code{ActiveJmsResourceAdapter} is to provide a communication interface between Glassfish and any kind of external message broker supporting the JMS API.  

As defined by Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/Java_Message_Service}},
\begin{quote}the \textbf{Java Message Service (JMS) API} is a Java Message Oriented Middleware (MOM) API for sending messages between two or more clients. It is a messaging standard that allows application components based on the Java Enterprise Edition (Java EE) to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous.
\end{quote}

The full JMS specification is available at Oracle's Developer Website\footnote{\url{http://www.oracle.com/technetwork/java/jms/index.html}}; we include the key architectural diagram here: 
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=250pt,keepaspectratio]{images/jms-programmingModel.png}}
\end{figure}

The \code{ActiveJmsResourceAdapter} component is essential for Glassfish to provide its hosted applications the messaging functionalities of the JMS API without having to implement a full message broker directly; instead, the system administrator is able to freely choose one (or more) of the existing commercial message brokers and configure Glassfish to route all JMS calls to it. In practice, it gives hosted applications a virtual, monolithic JMS message broker that they can interact with, fully abstracting all the implementation details of the specific adopted software solution.

In particular, it has the ability to connect with multiple message brokers at the same time to evenly distribute the amount of messages to be routed for performance and scalability reasons. Since each message broker has its own specific set of APIs, the actual implementation of the communication adapter is not directly provided by \code{ActiveJmsResourceAdapter}, which only acts as a general interface, but is offered by a set of different classes (one for each message broker) implementing the \code{ManagedConnectionFactory} interface which are dynamically loaded at runtime when needed.

Each distinct message broker is identified in Glassfish with a connector, which in turn can be associated with multiple connections at the same time. All the implementation details required to correctly interact with the message broker, including the name of the adapter class to be loaded, the values of the configuration properties and parameters and the maximum number of supported connections are specified by a \code{ConnectorConnectionPool} object. Despite the name, this object doesn't implement itself a connection pool, as it doesn't keep track of the connections that have been opened toward a certain message broker, instead being specifically concerned with the configuration details of the interface. The information provided by the \code{ConnectorConnectionPool} object is then used to dynamically load and instantiate the required \code{ManagedConnectionFactory} class.

The \code{createManagedConnectionFactory} method is precisely involved with the setup of the \code{ManagedConnectionFactory} object responsible for the communication with JMS compliant message brokers. The first instruction is a call to the inherited version of this same method, which performs three tasks:
\begin{itemize}
	\item It dynamically loads the class implementing the desired \code{ManagedConnectionFactory} implementation and instantiates it;
	\item For every property enumerated in the given \code{ConnectorConnectionPool}, it uses Java reflection to find out which is the corresponding setter method and invokes it to assign the proper value to all the specified class attributes;
	\item If everything has been successful, it returns a pointer to the created \code{ManagedConnectionFactory} instance; otherwise, it returns null.
\end{itemize}

However, this code is only able to configure properties for which a setter with the same name exists. Apparently, older implementations of the MQ API only provided properties in the form of \code{$\langle$property, value$\rangle$} tuples which had to be passed to a \code{setProperty(String property, String value)} method; this properties starting with the “imq” prefix are thus not set by the initial call of the super \code{createManagedConnectionFactory} method.

For this reason, if a valid \code{ManagedConnectionFactory} instance is returned, the method proceeds to check all the properties stated in the \code{ConnectorConnectionPool} object looking for those who have “imq” as a prefix and, if any of them is found, it uses Java reflection to obtain the \code{setProperty(String property, String value)} method of the \code{ManagedConnectionFactory} and invokes it with the corresponding \code{$\langle$property, value$\rangle$} tuple. If no such method is found, then an exception is raised.

For compatibility reasons, most properties still have an old, deprecated imq version and a newer official version, which should be used in lieu of the old one. If the two are present with different values in the same file, it is assumed that the newer one should be considered as the legal one.

However, since the imq loop is executed after all “newer” properties have already been set, if a lazy developer has actually included both the imq version and the newer official version of the same property in the same file, the value of the imq version will overwrite the newer one as its corresponding setter is called later.

As this is in contrast with the specification, Glassfish includes a fix for this behavior which consists of simply re-invoking all the setter methods for the official properties, with the single exception of the \code{addressList} property which is removed in case the address is equal to localhost or is empty (as it is considered to be “less important” than a non-empty and non-localhost imq \code{addressList}). This check is only performed if the interfacing module is a JMS module, which in fact is a superfluous check as \code{ActiveJmsResourceAdapter} only deals with JMS modules. 

As we were mentioning earlier, \code{ActiveJmsResourceAdapter} is able to associate multiple message brokers to the same virtual connector in order to achieve better scalability and performances. The interactions between all the resource managers (in this case, message brokers) are governed by the XA standard, which uses two-phase commit to ensure that transactions related to the processing of messages are correctly handled by all nodes.

The \code{createManagedConnectionFactories} method is invoked when it's necessary to gather all the \code{ManagedConnectionFactories} corresponding to a single pool of message broker addresses.

As the author of the code states, this is particularly useful when the XA resources of all resource managers in a broker cluster are required for a certain transaction and thus we need to simultaneously get a reference to all the message brokers in the cluster to eventually instantiate a connection with each of them. In this case, the process is quite straightforward.

At first, the method determines how many message brokers are part of the cluster by counting the number of remote addresses in the pool. If only one message broker is present, a single \code{ManagedConnectionFactory} is created; otherwise, a list of all addresses is obtained by analyzing both the imqAddressList and the AddressList properties (if present) and for each of them a \code{ManagedConnectionFactory} is created. The process is similar to what we've already seen for the single \code{ManagedConnectionFactory}: the super method is invoked for the initial allocation and configuration phase, then all imq properties are set. The conflict resolution policy for imq and non-imq properties adopted in this case is different from what we've seen in the single factory case: this time, only the \code{addressList} property is resolved giving more importance to its non-imq version, while for all other properties the imq version overrides the non-imq one if both are present.

This different behavior is not documented at all, though, so our understanding is that the conflict resolution policy may not be stated by the properties specifications.