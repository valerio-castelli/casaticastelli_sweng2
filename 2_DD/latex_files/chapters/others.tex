\chapter{Algorithm Design}
In this section we will give an overall description of the main algorithms necessary for myTaxiService to work. 

Each algorithm will be explained using a pseudo-code notation inherited from the Java programming language; for the sake of simplicity, we will assume to have a class for each sub-component, even though in the real implementation the code will be split among multiple helper classes.
\vspace{5px}
\linebreak
The first algorithm we will focus on is the Taxi Request processing algorithm, which takes a Taxi Request in input and performs the necessary operations to handle it. The main algorithm is described by the requestTaxi(...) method of the RequestManagement component.

The most critical aspect of the algorithm is the proper management of the queues in a concurrent environment. In fact, every request is processed independently in a different thread for efficiency reasons: this means that accesses to queues must be managed in a way that ensures proper and consistent sorting of taxis.

This is achieved by using an additional mapping data structure in each thread that associates to every taxi contained in the queue of the interested zone a special checked/unchecked status. 
At the beginning of the requestTaxi() method, all taxis in the interested zone are inserted in the map with an unchecked status. A taxi is then considered checked if the algorithm has already considered it for the given request and the taxi driver has refused it; this way, it won't be considered again for the same request. 

In order to keep this map data structure updated with respect to the insertion and removal of taxis in/from the interested zone queue, an instance of the observer design pattern is implemented between the TaxiManagement component and the zone queue object. Specifically, the thread responsible of a specific request registers itself as an observer of the interested zone queue object by exposing a couple of callbacks that are called every time a taxi is inserted or removed in/from the zone queue. The behavior of these callbacks is designed to keep the internal thread data structure consistent with the behavior of a queue; more specifically:
\begin{itemize}
	\item When a taxi is removed from the original zone queue, it is removed from the map only if it hasn't already been checked. In fact, to guarantee convergence the algorithm must remember the taxis that have already been checked. If the taxi is still marked as unchecked, then it can be safely removed; in this case, two scenarios are possible:
	\begin{enumerate}
	\item The taxi has been removed because it's become unavailable or it has gone out of the zone. 
	\item The taxi has been selected to serve another request.	\end{enumerate}
	In both cases, it is correct to remove the taxi from the map, since it wouldn't be available to serve our request anyway. The removal of the taxi from the map allows the system to insert it back later on if it becomes available again.
	\item When a taxi is added to the original zone queue, it is added to the map only if it hasn't already been stored inside it. In this way, a taxi can be stored in the map only if one of these two conditions holds:
	\begin{enumerate}
		\item The taxi is coming from another zone. In this case, it represents a new taxi for us that wasn't previously available for selection. 
		\item The taxi was already present in our zone, it had been selected to serve another request but has refused to serve it. In this case, the taxi could still choose to serve our request, so it must be considered for selection. 
	\end{enumerate}
	In both cases, the taxi is added into the last position of the map. This is consistent with the specifications, as it will respect the priority order of the queue and will allow the system to consider more taxis as they become suitable for selection. 
\end{itemize}
It should be noted that this add/remove policy ensures that no taxi is ever considered twice for the same request: even if it is taken from the pool to serve another request, if it had already been considered for this one his checked status will be kept and this will avoid multiple checks of the same taxi.

In the end, this guarantees that the algorithm converges in at most N iterations, N being the total number of taxis in the system (if they are all available and present inside the same zone, and all of them refuse the call). 

\begin{lstlisting}
public class RequestManagement{ 
public boolean requestTaxi(passengerID, address){
	Location l = locationManagement.getLocation(address);
	return requestTaxi(passengerId, l);
}

public boolean requestTaxi(passengerID, passengerLocation, destination){
	boolean consistency = checkDataConsistency(passengerID, passengerLocation, destination);
	if (consistency){
		// We create a new request and write it into the database 
		Request request = new Request(passengerID, passengerLocation);
		dataAccessUtilities.writeToDB(request);
		/* We compute the zone of the source */
		Zone z = locationManagement.getZone(passengerLocation);
		/* Is there an available taxi? */
		if (taxiManagement.existsAvailableTaxiDriver(request, zone)){
			/* If so, get it and compute the ETA and the secret code */
			TaxiDriver td = taxiManagement.getAvailableTaxiDriver(request);
			int ETA = taxiManagement.getETA(td, passengerLocation);
			String secretCode = generateSecretCode();
			/* We notify it to the taxi driver and to the passenger*/
			notificationSystem.notifyRequestConfirmation(td, request, secretCode);
			notificationSystem.notifyRequestConfirmation(passenger, request, secretCode)
	}
		else
			/* Otherwise we reject the request */
				notificationSystem.notifyRequestRejection(passenger);
		/* Finally we update the status of the request in the database */
		dataAccessUtilities.updateDB(request);	
	}
	else
		/* Data is inconsistent, notify error */
		notificationSystem.notifyErrorInRequest(passengerID);
	return consistency;
}

private boolean checkDataConsistency(origin, destination){
	Location origin_l = locationManagement.getLocation(address);
	if (locationManagement.isLocationInsideCity(origin_l) 
		return true;
	return false; 
}
}

public class LocationManagement{
public Location getLocation(address){
	return mappingService.getLocation(address);
}
}

public class RemoteServicesInterface{
public void acceptRide(td, request){
	taxiManagement.acceptRide(td, request);
}
}

public class TaxiManagement{

private boolean accepted;
private boolean answered;
/* We keep a list of already checked taxis */
private SortedMap checkedTaxi = new SortedMap();

private void notifyQueueUpdateToTaxis(zone){
	ZoneQueue queue = getZoneQueue(zone);
	for (int i = 0; i<queue.getSize(); i++)
		notificationSystem.notifyQueueUpdate(queue.get(n), n, queue.getSize());
}


public void acceptRide(td, request){
	answered = true;
	accepted = true;
}

public void refuseRide(td, request){
	answered = true;
	accepted = false;
}

public int getETA(passengerLocation){
	return mappingService.computeETA(passengerLocation, td.getLocation());
}

private void setPending(td){
	td.setStatus(pending);
	dataAccessUtilities.updateTaxiStatus(td.getStatus());
}

private void setCurrentlyRiding(td, request){
	td.setStatus(currentlyRiding);
	moveTaxiToCurrentlyRidingList(td);
	td.associateRequest(request);
	dataAccessUtilities.updateTaxiStatus(td.getStatus());
}

/* Callback invoked by the zone queue update method when a new taxi driver is inserted in the zone queue */
public void callbackNotifyAddedTaxi(TaxiDriver td){
	if (!checkedTaxi.contains(td))
		checkedTaxi.add(td, UNCHECKED);
}

/* Callback invoked by the zone queue update method when a taxi
driver is removed from the zone queue */
public void callbackNotifyRemovedTaxi(TaxiDriver td){
	if (checkedTaxi.getValue(td)==UNCHECKED)
		checkedTaxi.remove(td);
}

/* The queue is frozen while I'm filling the hashmap */
private synchronized void initializeHashMap(ZoneQueue queue){
	for (int i = 0; i < zoneQueue.getSize(); i++)
		checkedTaxi.add(zoneQueue.get(i), UNCHECKED);		
}

public boolean existsAvailableTaxiDriver(zone){
	
	ZoneQueue zoneQueue = getZoneQueue(zone);
	initializeHashMap(zoneQueue);
	zoneQueue.addObserver(this);
	accepted = false;
	answered = false;
	/* While there are still taxis to be checked and nobody has accepted */
	for (int i = 0; !accepted && (i < checkedTaxi.getSize()); i++)	
	{
		/* We pop the first available taxi */
		TaxiDriver td = checkedTaxi.get(i);
		zoneQueue.remove(td);
		/* We set it as pending */
		setPending(td);
		/* And notify him the request */
		notificationSystem.notifyCallRequest(td, request);
		/* Wait for the answer, or timeout */
		waitUntil(answered || timeout);
		if (!accepted){
			zoneQueue.enqueue(td);
			checkedTaxi.setValueForKey(i, CHECKED);
		}
		else
			setCurrentlyRiding(td, request);
		/* In both cases, we have to notify other drivers of the update of the queue */
		notifyQueueUpdateToTaxis(zone);
	}
	return accepted;
}

}	
\end{lstlisting}

The second algorithm we will focus on is the Taxi Reservation processing algorithm, which takes a Taxi Reservation in input and performs the necessary operations to handle it. The main algorithm is described by the reserveTaxi(...) method of the ReservationManagement component.

\begin{lstlisting}
public class ReservationManagement{

	public boolean reserveTaxi(passengerID, origin, destination, date, time){
		/* Verifies that inserted data are consistent and valid */
		boolean consistency = checkDataConsistency(passengerID, origin, destination, date, time);
		if (consistency){
			/* Allocate the reservation and store it into the database */
			Reservation reservation = new Reservation(origin, destination, date, time);
			insertNewReservation(reservation);
			/* Notify the passenger that the reservation has been registered */
			notificationSystem.confirmReservation(passengerID, reservation);
		}
		else
			/* Data is inconsistent, notify error */
			notificationSystem.notifyErrorInReservation(passengerID);
		return consistency;
	}
	
	private insertNewReservation(reservation){
		dataAccessUtilities.insertReservation(reservation);
	}
	
	private boolean checkDataConsistency(origin, destination, date, time){
		Location origin_l = locationManagement.getLocation(address);
		if (locationManagement.isLocationInsideCity(origin_l) && 
		(timeInterval(currentDateTime(),createDateTime(date,time)) between 2 hours and 15 days))
			return true;
		return false; 
	}
}	
\end{lstlisting}

The third algorithm we will focus on is the one that manages the behavior of the availability toggle for taxi drivers. The main algorithm is described by the togglePressed(taxiDriverId) method of the TaxiManagement component.
\begin{lstlisting}
public class TaxiManagement{

	public void togglePressed(taxiDriverId){
		TaxiStatus status = checkStatus(taxiDriverId);
		Zone zone = locationManagement.getZone(taxiDriverId);
		switch(status){
			case TaxiStatusAvailable:{
				removeTaxiFromZoneQueue(taxiDriverId);
				setUnavailable(taxiDriverId);
				dataAccessUtilities.updateQueues();
				dataAccessUtilities.updateTaxiStatus(taxiDriverId, TaxiStatusAvailable);
				notifyQueueUpdateToTaxis(zone);
				break;
			}
			case TaxiStatusOutsideCity:{
				remoteTaxiFromOutsideCityList(taxiDriverId);
				setUnavailable(taxiDriverId);
				dataAccessUtilities.updateQueues();
				dataAccessUtilities.updateTaxiStatus(taxiDriverId, TaxiStatusAvailable);
				notifyQueueUpdateToTaxis(zone);
				break;
			}
			case TaxiStatusCurrentlyRiding:{
			/* A taxi cannot change his status while on a ride */
			notificationSystem.rejectAvailabilityChange(taxiDriverId);
			}
			case TaxiStatusPending:{
			/* A taxi cannot change his status while he's got a pending request */
			notificationSystem.rejectAvailabilityChange(taxiDriverId);
			}
			case TaxiStatusUnavailable:{
				Location l = getTaxiDriverLocation(taxiDriverId);
				if (locationManagement.isLocationInsideCity(l)){
					setAvailable(taxiDriverId);
					notifyQueueUpdateToTaxis(zone);
					notificationSystem.confirmAvailability(taxiDriverId);
				}
				else 
					notificationSystem.rejectAvailabilityChange(taxiDriverId);
				break;
			}
		}
	}

	private getTaxiById(taxiDriverId){
		/* We have to get the corresponding taxi */
		/* First look through the zones to see if the driver is available */
		for (int zone = 0; z < zoneNumber; z++){
			for (int n = 0; n < getZoneQueue(zone).getSize(); n++)
				if (getZoneQueue(zone).get(n).getDriverId == taxiDriverId)
					return getZoneQueue(zone).get(n);
		}
		/* If not, is he outside city? */
		for (int n = 0; n < outsideCityList.getSize(); n++)
			if (outsideCityList.get(n).getDriverId == taxiDriverId)
				return outsideCityList.get(n);
		/* If not, is he on a ride? */
		for (int n = 0; n < currentlyRidingList.getSize(); n++)
			if (currentlyRidingList.get(n).getDriverId == taxiDriverId)
				return currentlyRidingList.get(n);
		/* If not, is he unavailable ? */
		for (int n = 0; n < unavailabilityList.getSize(); n++)
			if (unavailabilityList.get(n).getDriverId == taxiDriverId)
				return unavailabilityList.get(n);
		/* If we still haven't found him, we have a serious problem */
		throw new TaxiNotFoundException();		
	}

	private TaxiStatus checkStatus(taxiDriverId){
		Taxi taxi = getTaxiById(taxiDriverId);
		return taxi.getStatus();
	}
}
\end{lstlisting}

The fourth algorithm we will focus on is the one that manages the transition of a taxi from a zone to another. The main algorithm is described by the sendCurrentLocation(taxiId,currentLocation) method of the TaxiManagement component.

\begin{lstlisting}
public class TaxiManagement{
	
	public void sendCurrentLocation(taxiId,currentLocation){
		Taxi taxi = getTaxiById(taxiDriverId);
		TaxiStatus status = checkStatus(taxiDriverId);
		Zone oldZone = locationManagement.getZone(taxi.getLocation());
		/* The zone change has an impact only if the taxi is available */
		if (status==TaxiStatusAvailable){
			if (locationManagement.isLocationInsideCity(currentLocation)){
				/* If it's inside the city, it should change zone */
				Zone newZone = locationManagement.getZone(currentLocation);
				if (oldZone!=newZone)){
					updateZone(taxi,newZone);
					/* We have to notify the other drivers in the new zone of the change */
					notifyQueueUpdateToTaxis(newZone);
					dataAccessUtilities.updateQueues();
					
				notificationManager.notifyZoneChanged(taxiId,newZone);
				}
			}
			else{
				/* Otherwise it should be set as "out of city" */
				setOutsideCity(taxiId);
				dataAccessUtilities.updateQueues();
				notificationManager.notifyExitedCity(taxiId);
			}
			/* We have to notify the other drivers in the old zone of the change */
			notifyQueueUpdateToTaxis(oldZone);
		}
	else if (status==TaxiStatusOutsideCity){
		/* Are we getting inside the city? */
		if (locationManagement.isLocationInsideCity(currentLocation)){
			/* If so, we have to compute the zone in which we have entered */
			Zone newZone = locationManagement.getZone(currentLocation);
				setAvailable(taxi);
				enqueueTaxiDriver(taxi,newZone);
				/* We have to notify the other drivers in the new zone of the change */
				notifyQueueUpdateToTaxis(newZone);
				dataAccessUtilities.updateQueues();
				notificationManager.notifyEnteredCity(taxiId,newZone);
				
		}
		/* Otherwise we don't really care */
	}
	updateTaxiLocation(taxiId,currentLocation);
	}
	
	private void updateTaxiLocation(taxi,currentLocation){
		taxi.setLocation(currentLocation);
	}
	
}
\end{lstlisting}

\chapter{User Interface Design}
One of the main concerns with designing an Information System is how to make it as functional and user-friendly as possible. The simplicity and clarity of the user interface is crucial in making sure that the system can actually be employed by the intended user base in an efficient way; in increases user satisfaction with the services and reduces the need to have a support staff. 
For this reason, we have designed the User Interfaces of our client applications in accordance to the main principles of UI Design outlined by Jef Raskin in his book "The Humane Interface", as referenced at the beginning of this document. 

Another important aspect that we have considered while designing the UI of our client applications is related to the adaptability of the UI to different screens and device form factors. 

In order to satisfy this requirement, the mobile applications have been designed to natively support both smartphones and tablets. More specifically, this implies that each mobile application actually includes two different user interfaces, each uniquely optimized and tailored to the specific kind of device being used. To keep the user experience consistent across devices, the two UIs are built around the same design language and share many visual traits. 

Furthermore, the mobile applications UIs have been designed to be resolution independent. In particular, we have chosen an interface design which can be easily displayed on screen sizes between 3" and 6" (when used on a mobile phone) and between 7" and 12" (when used on a tablet); this requirement will be effectively satisfied in the implementation phase by making usage of appropriate libraries that support vector graphics, proportional spacing and scaling functionalities.

Both the Passenger Web Application and the Administration Web Application components have to be implemented to properly address dynamic web page resizing by proportionally scaling header, footer and side bars to the amount of available space without stretching individual components and forms. Furthermore, they have to be offered both in a desktop version and in a mobile-friendly version; for simplicity, in the sketches only the desktop version is shown, with the mobile-friendly version closely resembling their application counterparts. 

In addition, both the mobile applications and the web applications are implemented to be accessible by blind people. This requirement is translated differently for the two kinds of application:
	\begin{itemize}
	\item The Web Applications must use standard HTML components and include the appropriate tags to be interpreted by screen reader software in a meaningful way
	\item The Mobile Applications must implement appropriate voice description APIs offered by the platform they're running on (as VoiceOver in iOS)
	\end{itemize}

Many detailed mockups regarding the Taxi Driver Mobile Application, the Passenger Mobile Application and the Passenger Web Application have already been included in the RASD, so we will not not include them again in this document. 
However, we are including a few mockups of the Administration Web Application. 

The following sketch shows a possible implementation of the main page of the admin web application. 
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=450pt,keepaspectratio]{images/sketches/Admin_Home.png}}
\end{figure}
\pagebreak
The following sketch shows how the taxi driver insertion page is designed. 
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=450pt,keepaspectratio]{images/sketches/Admin_Insert_Taxi_Driver.png}}
\end{figure}

The following sketch shows how the list of all taxi drivers is displayed.
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=450pt,keepaspectratio]{images/sketches/Admin_Taxi_Drivers_List.png}}
\end{figure}

\pagebreak
The following sketch shows how the zone update page is designed. 
\begin{figure}[H]
\centering
\makebox[\columnwidth]{\includegraphics[width=450pt,keepaspectratio]{images/sketches/Admin_Zone_Update.png}}
\end{figure}

\chapter{Requirements Traceability}
In this section we'll specifically cover in detail how the requirements identified in the SRS document are satisfied by our myTaxiService architecture. 

\section{Functional Requirements}

For sake of readability, we will use the notation \textbf{req. x.y} to make reference to the y-th requirement associated with the x-th goal.

\begin{itemize}
	\item \textbf{Goal 1, 2 and 3} are essentially administration-oriented requirements; as such, they are satisfied by:
	\begin{itemize}
	\item The \textbf{System Administration} component, which provides the backend business logic to handle the required data modification operations. In particular, operations related to taxi and taxi drivers (goal 1, 2) are handled by the Taxi Driver Management sub-component, while operations related to the definition of taxi zones (goal 1, 3) are handled by the Zone Division Management sub-component.
	\item The \textbf{Administration Web Application} component, which provides administrators an appropriate user interface to interact with the backend.
	\end{itemize}
	\item \textbf{Goal 4} describes the way in which the availability status of a taxi driver is updated. As such, several components are involved in its fulfillment:
	\begin{itemize}
	\item The \textbf{Taxi Driver Application} component, which provides taxi drivers the ability to interact with the central system to notify a change in their availability status. In particular, this component is responsible for reqs. 4.1 to 4.6 and reqs. 4.8, 4.11.
	\item The \textbf{Taxi Management System} component, which provides the backend business logic to handle the update operations. In particular:
	\begin{itemize}
	\item Req. 4.6 and 4.7 are handled by the Location Management sub-component for the zone computation part and by the Taxi Management sub-component for the update operation on taxi queues
	\item Reqs 4.9 and 4.10 are handled by the Taxi Management sub-component by moving the taxi to the unavailability list and setting its status to unavailable
	\item Req. 4.8 and 4.11 are handled by the Taxi Management sub-component
	\end{itemize}
	\item The \textbf{Notification System} component, which provides to the central system the dispatch mechanism it needs for sending notifications to the taxi driver application. This component is essentially involved in satisfying reqs. 4.6, 4.8 and 4.11.
	\end{itemize}
	\item \textbf{Goal 5} requires the allocation and distribution of taxis to be managed fairly and consistently. This is achieved by an interplay of components: 
	\begin{itemize}
	\item The \textbf{Taxi Management System} is the key component that concurs to the fulfillment of the goal. More specifically, reqs. 5.1 to 5.12 are handled by the Taxi Management sub-component, with the aid of the Location Management sub-component as for those requirements that involve checking whether the taxi driver is still inside the city or not. 
	\item The \textbf{Taxi Driver Application} component is crucial in fulfilling reqs 5.13 and 5.14 by providing an appropriate management of the UI to prevent incorrect availability assignments and by sending the GPS coordinates of the taxi driver to the central system with a given frequency.
	\item The \textbf{Remote Services Interface} component, which enables the taxi driver application to request services to the central system and thus provides the necessary callbacks to satisfy req. 5.14. 	
	\end{itemize}
	\item \textbf{Goal 6} is related to the ability of a taxi driver to receive, accept and refuse ride requests. This involves:
	\begin{itemize}
	\item The \textbf{Taxi Management System} component, which is responsible of fulfilling reqs. 6.1, 6.2, and 6.4 to 6.6 by means of the Taxi Management sub-component.
	\item The \textbf{Mapping Service} component, which provides the reverse-geocoding capability to fulfill req. 6.2 and the map data to fulfill req. 6.8.
	\item The \textbf{Taxi Driver Application} component, which is responsible of fulfilling reqs. 6.1, 6.3, 6.7 and 6.8 by providing to the taxi driver an appropriate UI.
	\item The \textbf{Notification System} component, which provides to the central system the dispatch mechanism it needs for sending notifications to the taxi driver application and fulfill req 6.1.
	\item The \textbf{Remote Services Interface} component, which enables the taxi driver application to request services to the central system and thus provides the necessary callbacks to satisfy reqs. 6.4 and 6.5.
	\end{itemize}
	\item \textbf{Goal 7} gives a taxi driver the ability to drop a request if the passenger doesn't show up. In order for this functionality to work correctly, several components should cooperate:
	\begin{itemize}
	\item The \textbf{Taxi Driver Application} component, which provides a suitable UI to drop the request (req. 7.1) and retrieves the current GPS location fo the taxi driver in order to let the central system check if it matches the agreed meeting point (req. 7.2).
	\item The \textbf{Taxi Management System} component, which is responsible of satisfying all the three requirements related to this goal, in particular my means of the Taxi Management and Request Management sub-components.
	\item The \textbf{Passenger Application} component, which is responsible of implementing a suitable UI view to notify a passenger that his request has been dropped (req. 7.3).
	\item The \textbf{Notification System} component, which provides to the central system the dispatch mechanism it needs for sending notifications to both the taxi driver application and the passenger application and fulfill req 7.3.
	\item The \textbf{Remote Services Interface} component, which enables the taxi driver application to request services to the central system and thus provides the necessary callbacks to satisfy reqs. 7.1 and 7.2.
	\end{itemize}
	\item \textbf{Goal 8} gives a taxi driver the ability to notify the central system when he has completed a ride. In order for this functionality to work correctly, several components should cooperate:
	\begin{itemize}
	\item The \textbf{Taxi Driver Application} component, which provides a suitable UI to mark the end of the ride (req. 8.1) and retrieves the current GPS location fo the taxi driver in order to let the central system check if it matches the agreed meeting point (req. 8.2) and the destination point (req. 8.3).
	\item The \textbf{Taxi Management System} component, which is responsible of satisfying all the five requirements related to this goal, in particular my means of the Taxi Management and Request Management sub-components. Also, the Location Management sub-component is specifically employed to satisfy req. 8.4 and 8.5.
	\item The \textbf{Remote Services Interface} component, which enables the taxi driver application to request services to the central system and thus provides the necessary callbacks to satisfy reqs. 8.1 to 8.3.
	\end{itemize}
	\item \textbf{Goal 9} is arguably one of the most important functionalities of the system, as it is related to the ability of passengers to request taxi rides. As such, it involves many different components:
	\begin{itemize}
		\item The \textbf{Taxi Management System} component, which implements all the backend business logic to handle taxi requests. In particular:
		\begin{itemize}
		\item Reqs. 9.3 and 9.4 are handled by the Request Management and the Location Management sub-components.
		\item Req. 9.8 is handled by the Location Management sub-component, which is responsible for computing the taxi zone associated with a certain location.
		\item Req. 9.9 to 9.16 are handled by the Taxi Management sub-component and, for those operations involving the status of a pending request, by the Request Management sub-component.
		\end{itemize}
		\item The \textbf{Mapping Service} component, which is used to calculate the ETA for req. 9.10 and to perform the reverse-geocode location needed to fulfill reqs. 9.3, 9.4 and also 9.8 if the location is an address.
		\item The \textbf{Passenger Application} component, which provides a suitable UI to fulfill reqs. 9.1, 9.2.1, 9.2.2, 9.5 to 9.7 and 9.10.
		\item The \textbf{Passenger Web Application} component, which provides a suitable UI to fulfill reqs. 9.1, 9.2.3 and 9.10.
		\item The \textbf{Taxi Driver Application} component, which provides a suitable UI to alert the taxi driver he has been moved to the last position of its zone queue after refusing a request (req. 9.11).
		\item The \textbf{Remote Services Interface} component, which enables the passenger applications (web and mobile) to request services to the central system and thus provides the necessary callbacks to satisfy req 9.2.
		\item The \textbf{Notification System} component, which provides to the central system the dispatch mechanism it needs for sending notifications to both the taxi driver application and the passenger applications and fulfill reqs 9.10 to 9.12 and 9.16.
	\end{itemize}
	\item \textbf{Goal 10} requires the system to offer passengers a way to register. This goal is satisfied by an interplay of four components:
	\begin{itemize}
		\item The \textbf{Account Management} component, specifically the Passenger Registration sub-component, is responsible of offering the backend services that enables passenger registration and validation of the required data. 
		\item The \textbf{Passenger Web Application} component, which provides the registration entry form.
		\item The \textbf{Remote Services Interface} component, which enables the passenger web application to request services to the central system and thus provides the necessary callbacks to invoke the registration procedure.
		\item The \textbf{Notification System} component, which lets the central system send a notification containing the result of the registration process to the passenger web application.
	\end{itemize}
	\item \textbf{Goal 11} is arguably one of the most important functionalities of the system, as it is related to the ability of passengers to reserve taxi rides. As such, it involves many different components:
	\begin{itemize}
		\item The \textbf{Account Management} component, which is responsible for providing the required authentication capability using its Login sub-component and for maintaining the association between a passenger and its requests (req. 11.1).
		\item The \textbf{Taxi Management System} component, which implements all the backend business logic to handle taxi reservations. In particular:
		\begin{itemize}
		\item Reqs. 11.3 is handled by the Reservation Management and the Location Management sub-components.
		\item Reqs. 11.6 to 11.15 are handled by the Reservation Management sub-component.
		\item Req. 11.10 is handled by the Location Management sub-component, which is responsible for computing the taxi zone associated with a certain location.
		\item Req. 11.10 is also handled by the Request Management sub-component, which is used to associate a reservation to a taxi request. 
		\item Req. 11.10, 11.14 and 11.15 are handled by the Taxi Management sub-component.
		\end{itemize}	
		\item The \textbf{Passenger Application} component, which provides a suitable UI to fulfill reqs. 11.1, 11.2.1, 11.4 to 11.7, 11.11 to 11.13 and 11.15.
		\item The \textbf{Passenger Web Application} component, which provides a suitable UI to fulfill reqs. 11.1, 11.2.2, 11.6, 11.7, 11.11 to 11.13 and 11.15.
		\item The \textbf{Taxi Driver Application} component, which provides a suitable UI to notify a taxi driver that he has been assigned a taxi request, as in goal 9.
		\item The \textbf{Remote Services Interface} component, which enables the passenger applications (web and mobile) to request services to the central system and thus provides the necessary callbacks to satisfy req 11.2.
		\item The \textbf{Notification System} component, which provides to the central system the dispatch mechanism it needs for sending notifications to both the taxi driver application and the passenger applications and fulfill reqs 11.9, 11.14 and 11.15.
		\end{itemize}
	\item \textbf{Goal 12} is related to the generation and validation of the security code associated to each ride. This involves:
	\begin{itemize}
	\item The \textbf{Taxi Management System} component, in particular the Taxi Management and Request Management sub-components which are responsible for the generation of the security number (req. 12.1).
	\item The \textbf{Notification System} component, which is used to send the security number to both the taxi driver application and the passenger application (either the web app or the mobile app, depending on the case) in order to satisfy reqs. 12.2 and 12.3.
	\item The \textbf{Taxi Driver Application}, {Passenger Application} and {Passenger Web Application} components, which implement a suitable UI to show the received security number.
	\end{itemize}
	\end{itemize}

\section{Quality Requirements}

In this section we will describe in detail how myTaxiService has been designed to guarantee certain important Quality of Service (QoS) attributes.

In particular, we will focus on Performance, Reliability, Availability, Security and Portability requirements.

The usage of a Platform as a Service (PaaS) cloud infrastructure, combined with the n-tier and multi-layered software architecture we have chosen to adopt, provides myTaxiService a great level of performance. Specifically, the division of myTaxiService in a plethora of components implementing functionalities at different levels of abstraction and running on separate machines enables us to scale the hardware infrastructure as needed to achieve exactly the level of performance required. Concurrency requirements, for example, are satisfied by accurate load-balancing of requests across multiple servers running different instances of the same core services, in order to achieve a high level of parallelism and be able to serve as many requests as needed, with the option to increase the capabilities of the system in the future by renting more computation capabilities. 

The same n-tier infrastructure also let us achieve satisfying levels of availability and reliability, as the system components are distributed across several servers, possibly housed in different server farms by the cloud provider. Because of the way the PaaS cloud is designed, in case of failures requests can be smoothly transitioned from a server to another one without any interruption in the system operation; also, data is backed up across different locations, to provide a great level of resilience to natural disasters.

Security is achieved through both system-level and hardware-level measures. At the system level, the Account Manager and the System Administration components are responsible for checking that methods can only be invoked by authorized personnel. Furthermore, APIs are exposed via the Remote Services Interface in a way that prevents SQL injection attacks to take place and are invoked via secure token and encryption mechanisms to prevent man-in-the-middle attacks. DDoS attacks are mitigated by the presence of multiple load-balancers to redistribute requests across all the servers and thus minimize the possibility of a server going down due to the excessive amount of requests; a hardware firewall is also positioned at the boundaries of the central system to limit the number of ports that are publicly exposed and to temporarily ban IP addresses that are performing an excessive amount of requests in an attempt to block DDoS attacks. Other firewalls are positioned to separate the Communication Services Server from the servers providing the core functionalities of the system (Taxi Management, Account Management, System Administration and Database) and to separate the Database Server from everything else. All passwords are encrypted at the software level before being stored in the DBMS; to achieve better security, disks are physically encrypted at the hardware-level.

Finally, portability is achieved by exposing APIs using an open, standard web service mechanism based on SOAP. This allows the system to be invoked from any platform which can access the internet without restricting it to any particular operating system, hardware vendor or programming language. 

\begin{appendices}

\chapter{Hours of work}
To redact this document, we spent 50 hours per person.

\end{appendices}